package bow

import (
	"fmt"

	"github.com/apache/arrow/go/arrow/array"
)

func fillLeftBowColumns(newSeries *[]Series, left, right *bow, newNumRows, uniquesLeft int,
	commonCols map[string][]Series, commonRows struct{ l, r []int }) {
	var leftRow, commonRow int

	for colIndex := 0; colIndex < left.NumCols(); colIndex++ {
		leftRow = 0
		commonRow = 0
		(*newSeries)[colIndex] = NewSeriesEmpty(left.ColumnName(colIndex), newNumRows, left.ColumnType(colIndex))
		switch left.ColumnType(colIndex) {
        {{range .Data.types -}}
        case {{ .Type }}:
			leftData := array.New{{ .Type }}Data(left.Column(colIndex).Data())

			// Fill rows from left bow
			for newRow := 0; left.NumRows() > 0 && newRow < newNumRows; newRow++ {
				if left.Column(colIndex).IsValid(leftRow) {
					(*newSeries)[colIndex].SetOrDropStrict(newRow, leftData.Value(leftRow))
				}
				for commonRow < len(commonRows.l) &&
					commonRows.l[commonRow] == leftRow &&
					newRow < newNumRows {
					if left.Column(colIndex).IsValid(leftRow) {
						(*newSeries)[colIndex].SetOrDropStrict(newRow, leftData.Value(leftRow))
					}
					if commonRow+1 < len(commonRows.l) &&
						commonRows.l[commonRow+1] == leftRow {
						newRow++
					}
					commonRow++
				}
				if leftRow++; leftRow >= left.NumRows() {
					break
				}
			}

			// Fill remaining rows from right bow if column is common
			_, isColCommon := commonCols[left.ColumnName(colIndex)]
			var newRow int
			if isColCommon {
				newRow = left.NumRows() + len(commonRows.l) - uniquesLeft
			}
			for rightRow := 0; isColCommon && rightRow < right.NumRows(); rightRow++ {
				var isRowCommon bool
				for commonRow := 0; commonRow < len(commonRows.r); commonRow++ {
					if rightRow == commonRows.r[commonRow] {
						isRowCommon = true
						break
					}
				}
				if !isRowCommon {
					(*newSeries)[colIndex].SetOrDropStrict(newRow, commonCols[left.ColumnName(colIndex)][1].GetValue(rightRow))
					newRow++
				}
			}
        {{end -}}
		}
	}
}

func fillRightBowColumns(newSeries *[]Series, left, right *bow, newNumCols,
	newNumRows, uniquesLeft int, commonCols map[string][]Series,
	commonRows struct{ l, r []int }) {
	var leftRow, commonRow, rightCol int

	for colIndex := left.NumCols(); colIndex < newNumCols; colIndex++ {
		leftRow = 0
		commonRow = 0
		for commonCols[right.ColumnName(rightCol)] != nil {
			rightCol++
		}
		(*newSeries)[colIndex] = NewSeriesEmpty(right.ColumnName(rightCol), newNumRows, right.ColumnType(rightCol))
		switch right.ColumnType(rightCol) {
        {{range .Data.types -}}
        case {{ .Type }}:
			rightData := array.New{{ .Type }}Data(right.Column(rightCol).Data())

			// Fill common rows from right bow
			for newRow := 0; newRow < newNumRows; newRow++ {
				for commonRow < len(commonRows.l) &&
					commonRows.l[commonRow] == leftRow && newRow < newNumRows {
					if right.Column(rightCol).IsValid(commonRows.r[commonRow]) {
						(*newSeries)[colIndex].SetOrDropStrict(newRow, rightData.Value(commonRows.r[commonRow]))
					}
					if commonRow+1 < len(commonRows.l) &&
						commonRows.l[commonRow+1] == leftRow {
						newRow++
					}
					commonRow++
				}
				leftRow++
			}

			// Fill remaining rows from right bow
			newRow := left.NumRows() + len(commonRows.r) - uniquesLeft
			for rightRow := 0; rightRow < right.NumRows(); rightRow++ {
				var isRowCommon bool
				for commonRow := 0; commonRow < len(commonRows.r); commonRow++ {
					if rightRow == commonRows.r[commonRow] {
						isRowCommon = true
						break
					}
				}
				if !isRowCommon {
					if right.Column(rightCol).IsValid(rightRow) {
						(*newSeries)[colIndex].SetOrDropStrict(newRow, rightData.Value(rightRow))
					}
					newRow++
				}
			}
        {{end -}}
		}
		rightCol++
	}
}

func (b *bow) InnerJoin(other Bow) Bow {
	left := b
	right, ok := other.(*bow)
	if !ok {
		panic("bow.InnerJoin: non bow object passed as argument")
	}

	if left.NumCols() == 0 && right.NumCols() == 0 {
		return left.NewSlice(0, 0)
	}

	if left.NumCols() > 0 && right.NumCols() == 0 {
		return left.NewSlice(0, 0)
	}

	if left.NumCols() == 0 && right.NumCols() > 0 {
		return right.NewSlice(0, 0)
	}

	// Get common columns indexes
	commonCols := getCommonCols(left, right)

	// Get common rows indexes
	commonRows := getCommonRows(left, right, commonCols)

	// Prepare new Series Slice
	newNumCols := left.NumCols() + right.NumCols() - len(commonCols)
	newSeries := make([]Series, newNumCols)

	newNumRows := len(commonRows.l)
	var rightCol, leftRow, commonRow, newRow int

	// Fill left bow columns
	for colIndex := 0; colIndex < left.NumCols(); colIndex++ {
		newRow = 0
		commonRow = 0
		newSeries[colIndex] = NewSeriesEmpty(left.ColumnName(colIndex), newNumRows, left.ColumnType(colIndex))
		switch left.ColumnType(colIndex) {
        {{range .Data.types -}}
        case {{ .Type }}:
			leftData := array.New{{ .Type }}Data(left.Column(colIndex).Data())
			for leftRow = 0; leftRow < left.NumRows(); leftRow++ {
				if commonRow < len(commonRows.l) && commonRows.l[commonRow] == leftRow {
					if left.Column(colIndex).IsValid(leftRow) {
						newSeries[colIndex].SetOrDropStrict(newRow, leftData.Value(leftRow))
					}
					newRow++
					commonRow++
				}
			}
        {{end -}}
		}
	}

	// Fill right bow columns
	for colIndex := left.NumCols(); colIndex < newNumCols; colIndex++ {
		newRow = 0
		commonRow = 0
		for commonCols[right.ColumnName(rightCol)] != nil {
			rightCol++
		}
		newSeries[colIndex] = NewSeriesEmpty(right.ColumnName(rightCol), newNumRows, right.ColumnType(rightCol))
		switch right.ColumnType(rightCol) {
        {{range .Data.types -}}
        case {{ .Type }}:
			rightData := array.New{{ .Type }}Data(right.Column(rightCol).Data())
			// Fill common rows from right bow
			for leftRow = 0; leftRow < left.NumRows(); leftRow++ {
				if commonRow < len(commonRows.l) && commonRows.l[commonRow] == leftRow {
					if right.Column(rightCol).IsValid(commonRows.r[commonRow]) {
						newSeries[colIndex].SetOrDropStrict(newRow, rightData.Value(commonRows.r[commonRow]))
					}
					newRow++
					commonRow++
				}
			}
        {{end -}}
		}
		rightCol++
	}

	// Join Metadata
	var keys, values []string
	keys = append(keys, left.Schema().Metadata().Keys()...)
	keys = append(keys, right.Schema().Metadata().Keys()...)
	values = append(values, left.Schema().Metadata().Values()...)
	values = append(values, right.Schema().Metadata().Values()...)

	newBow, err := NewBowWithMetadata(
		NewMetadata(keys, values),
		newSeries...)
	if err != nil {
		panic(fmt.Errorf("bow.InnerJoin: %w", err))
	}

	return newBow
}
