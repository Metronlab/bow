package bow

import (
	"fmt"
    "github.com/apache/arrow/go/v8/arrow"
    "github.com/apache/arrow/go/v8/arrow/array"
    "github.com/apache/arrow/go/v8/arrow/bitutil"
    "github.com/apache/arrow/go/v8/arrow/memory"
)

// NewSeries returns a new Series from:
// - name: string
// - dataArray: slice of the data in any of the Bow supported types
// - validityArray:
//  - If nil, the data will be non-nil
//  - Can be of type []bool or []byte to represent nil values
func NewSeries(name string, dataArray interface{}, validityArray interface{}) Series {
	switch v := dataArray.(type) {
    {{range .Data.types -}}
	case []{{ .type }}:
		return new{{ .Type }}Series(name, v, buildNullBitmapBytes(len(v), validityArray))
    {{end -}}
	default:
		panic(fmt.Errorf("unsupported type '%T'", v))
	}
}

// NewSeriesFromBuffer returns a new Series from a name and a Buffer.
func NewSeriesFromBuffer(name string, buf Buffer) Series {
	switch data := buf.Data.(type) {
    {{range .Data.types -}}
	case []{{ .type }}:
		return new{{ .Type }}Series(name, data, buf.nullBitmapBytes)
    {{end -}}
	default:
		panic(fmt.Errorf("unsupported type '%T'", buf.Data))
	}
}

{{range .Data.types -}}
func new{{ .Type }}Series(name string, data []{{ .type }}, valid []byte) Series {
    {{ if .bufferMemoryMappingEqualArrow -}}
	length := len(data)
	return Series{
		Name: name,
		Array: array.New{{ .Type }}Data(
			array.NewData(mapBowToArrowTypes[{{ .Type }}], length,
				[]*memory.Buffer{
					memory.NewBufferBytes(valid),
					memory.NewBufferBytes(arrow.{{ .Type }}Traits.CastToBytes(data)),
				}, nil, length-bitutil.CountSetBits(valid, 0, length), 0),
		),
	}
	{{ else -}}
    mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
    builder := array.New{{ .Type }}Builder(mem)
    defer builder.Release()
    builder.AppendValues(data, buildNullBitmapBool(len(data), valid))
    return Series{Name: name, Array: builder.NewArray()}
	{{ end -}}
}

{{end -}}

// NewSeriesFromInterfaces returns a new Series from:
// - name: string
// - typ: Bow Type
// - data: represented by an slice of interface{}, with eventually nil values
func NewSeriesFromInterfaces(name string, typ Type, data []interface{}) Series {
	if typ == Unknown {
		var err error
		if typ, err = getBowTypeFromInterfaces(data); err != nil {
			panic(err)
		}
	}
    mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
	switch typ {
    {{range .Data.types -}}
	case {{ .Type }}:
		builder := array.New{{ .Type }}Builder(mem)
		defer builder.Release()
		builder.Resize(len(data))
		for i := 0; i < len(data); i++ {
			v, ok := To{{ .Type }}(data[i])
			if !ok {
				builder.AppendNull()
				continue
			}
            builder.Append(v)
		}
		return Series{Name: name, Array: builder.NewArray()}
    {{end -}}
	default:
		panic(fmt.Errorf("unsupported type '%s'", typ))
	}
}