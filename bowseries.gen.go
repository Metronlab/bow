// Code generated by bowseries.gen.go.tmpl. DO NOT EDIT.

package bow

import (
	"fmt"
	"github.com/apache/arrow/go/arrow"
	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/bitutil"
	"github.com/apache/arrow/go/arrow/memory"
)

func NewSeries(name string, dataArray interface{}, validityArray interface{}) Series {
	switch v := dataArray.(type) {
	case []int64:
		return newInt64Series(name, v, buildNullBitmapBytes(len(v), validityArray))
	case []float64:
		return newFloat64Series(name, v, buildNullBitmapBytes(len(v), validityArray))
	case []bool:
		return newBooleanSeries(name, v, buildNullBitmapBytes(len(v), validityArray))
	case []string:
		return newStringSeries(name, v, buildNullBitmapBytes(len(v), validityArray))
	default:
		panic(fmt.Errorf("unsupported type %T", v))
	}
}

func NewSeriesFromBuffer(name string, buf Buffer) Series {
	switch data := buf.Data.(type) {
	case []int64:
		return newInt64Series(name, data, buf.nullBitmapBytes)
	case []float64:
		return newFloat64Series(name, data, buf.nullBitmapBytes)
	case []bool:
		return newBooleanSeries(name, data, buf.nullBitmapBytes)
	case []string:
		return newStringSeries(name, data, buf.nullBitmapBytes)
	default:
		panic(fmt.Errorf("unsupported type '%T'", buf.Data))
	}
}

func NewSeriesFromInterfaces(name string, typ Type, cells []interface{}) Series {
	if typ == Unknown {
		var err error
		if typ, err = seekType(cells); err != nil {
			panic(err)
		}
	}
	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
	switch typ {
	case Int64:
		builder := array.NewInt64Builder(mem)
		defer builder.Release()
		builder.Resize(len(cells))
		for i := 0; i < len(cells); i++ {
			v, ok := ToInt64(cells[i])
			if !ok {
				builder.AppendNull()
				continue
			}
			builder.Append(v)
		}
		return Series{Name: name, Array: builder.NewArray()}
	case Float64:
		builder := array.NewFloat64Builder(mem)
		defer builder.Release()
		builder.Resize(len(cells))
		for i := 0; i < len(cells); i++ {
			v, ok := ToFloat64(cells[i])
			if !ok {
				builder.AppendNull()
				continue
			}
			builder.Append(v)
		}
		return Series{Name: name, Array: builder.NewArray()}
	case Boolean:
		builder := array.NewBooleanBuilder(mem)
		defer builder.Release()
		builder.Resize(len(cells))
		for i := 0; i < len(cells); i++ {
			v, ok := ToBoolean(cells[i])
			if !ok {
				builder.AppendNull()
				continue
			}
			builder.Append(v)
		}
		return Series{Name: name, Array: builder.NewArray()}
	case String:
		builder := array.NewStringBuilder(mem)
		defer builder.Release()
		builder.Resize(len(cells))
		for i := 0; i < len(cells); i++ {
			v, ok := ToString(cells[i])
			if !ok {
				builder.AppendNull()
				continue
			}
			builder.Append(v)
		}
		return Series{Name: name, Array: builder.NewArray()}
	default:
		panic(fmt.Errorf("unhandled type %s", typ))
	}
}

func newInt64Series(name string, data []int64, valid []byte) Series {
	length := len(data)
	return Series{
		Name: name,
		Array: array.NewInt64Data(
			array.NewData(mapBowToArrowTypes[Int64], length,
				[]*memory.Buffer{
					memory.NewBufferBytes(valid),
					memory.NewBufferBytes(arrow.Int64Traits.CastToBytes(data)),
				}, nil, length-bitutil.CountSetBits(valid, 0, length), 0),
		),
	}
}

func newFloat64Series(name string, data []float64, valid []byte) Series {
	length := len(data)
	return Series{
		Name: name,
		Array: array.NewFloat64Data(
			array.NewData(mapBowToArrowTypes[Float64], length,
				[]*memory.Buffer{
					memory.NewBufferBytes(valid),
					memory.NewBufferBytes(arrow.Float64Traits.CastToBytes(data)),
				}, nil, length-bitutil.CountSetBits(valid, 0, length), 0),
		),
	}
}

func newBooleanSeries(name string, data []bool, valid []byte) Series {
	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
	builder := array.NewBooleanBuilder(mem)
	defer builder.Release()
	builder.AppendValues(data, buildNullBitmapBool(len(data), valid))
	return Series{Name: name, Array: builder.NewArray()}
}

func newStringSeries(name string, data []string, valid []byte) Series {
	mem := memory.NewCheckedAllocator(memory.NewGoAllocator())
	builder := array.NewStringBuilder(mem)
	defer builder.Release()
	builder.AppendValues(data, buildNullBitmapBool(len(data), valid))
	return Series{Name: name, Array: builder.NewArray()}
}
