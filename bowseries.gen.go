// Code generated by bowseries.gen.go.tmpl. DO NOT EDIT.

package bow

import (
	"fmt"
	"reflect"
)

func NewSeries(name string, typ Type, dataArray interface{}, validityArray interface{}) Series {
	switch typ {
	case Int64:
		data, ok := dataArray.([]int64)
		if !ok {
			panic(fmt.Errorf(
				"bow.NewSeries: typ is %v, but have %v",
				typ, reflect.TypeOf(dataArray)))
		}
		return newInt64Series(name, data,
			buildNullBitmapBytes(len(data), validityArray))
	case Float64:
		data, ok := dataArray.([]float64)
		if !ok {
			panic(fmt.Errorf(
				"bow.NewSeries: typ is %v, but have %v",
				typ, reflect.TypeOf(dataArray)))
		}
		return newFloat64Series(name, data,
			buildNullBitmapBytes(len(data), validityArray))
	case Boolean:
		data, ok := dataArray.([]bool)
		if !ok {
			panic(fmt.Errorf(
				"bow.NewSeries: typ is %v, but have %v",
				typ, reflect.TypeOf(dataArray)))
		}
		return newBooleanSeries(name, data,
			buildNullBitmapBytes(len(data), validityArray))
	case String:
		data, ok := dataArray.([]string)
		if !ok {
			panic(fmt.Errorf(
				"bow.NewSeries: typ is %v, but have %v",
				typ, reflect.TypeOf(dataArray)))
		}
		return newStringSeries(name, data,
			buildNullBitmapBytes(len(data), validityArray))
	default:
		panic(fmt.Errorf("unsupported type %v", typ))
	}
}

func NewSeriesFromBuffer(name string, buf Buffer) Series {
	switch data := buf.Data.(type) {
	case []int64:
		return newInt64Series(name, data, buf.nullBitmapBytes)
	case []float64:
		return newFloat64Series(name, data, buf.nullBitmapBytes)
	case []bool:
		return newBooleanSeries(name, data, buf.nullBitmapBytes)
	case []string:
		return newStringSeries(name, data, buf.nullBitmapBytes)
	default:
		panic(fmt.Errorf("unsupported type '%T'", buf.Data))
	}
}
