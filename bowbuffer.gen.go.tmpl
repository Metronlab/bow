package bow

import (
    "fmt"

	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/bitutil"
)

func NewBuffer(size int, typ Type) Buffer {
	switch typ {
    {{range .Data.types -}}
	case {{ .Type }}:
		return Buffer{
			Data: make([]{{ .type }}, size),
			nullBitmapBytes: make([]byte, bitutil.CeilByte(size) / 8),
		}
    {{end -}}
	default:
		panic(fmt.Errorf("unsupported type %s", typ))
	}
}

func NewBufferFromData(dataArray interface{}, validityArray interface{}) Buffer {
	switch data := dataArray.(type) {
    {{range .Data.types -}}
	case []{{ .type }}:
		return Buffer{
			Data:            dataArray,
			nullBitmapBytes: buildNullBitmapBytes(len(data), validityArray),
		}
    {{end -}}
	default:
		panic(fmt.Errorf("unsupported type %T", dataArray))
	}
}


func (b *Buffer) Len() int {
	switch data := b.Data.(type) {
    {{range .Data.types -}}
	case []{{ .type }}:
		return len(data)
    {{end -}}
	default:
		panic(fmt.Errorf("unsupported type '%T'", b.Data))
	}
}

func (b *Buffer) SetOrDrop(i int, value interface{}) {
	var valid bool
	switch v := b.Data.(type) {
    {{range .Data.types -}}
	case []{{ .type }}:
		v[i], valid = {{ .Type }}.Convert(value).({{ .type }})
    {{end -}}
	default:
		panic(fmt.Errorf("unsupported type %T", v))
	}

	if valid {
		bitutil.SetBit(b.nullBitmapBytes, i)
	} else {
		bitutil.ClearBit(b.nullBitmapBytes, i)
	}
}

func (b *Buffer) SetOrDropStrict(i int, value interface{}) {
	var valid bool
	switch v := b.Data.(type) {
    {{range .Data.types -}}
	case []{{ .type }}:
		v[i], valid = value.({{ .type }})
    {{end -}}
	default:
		panic(fmt.Errorf("unsupported type %T", v))
	}

	if valid {
		bitutil.SetBit(b.nullBitmapBytes, i)
	} else {
		bitutil.ClearBit(b.nullBitmapBytes, i)
	}
}

func (b *Buffer) GetValue(i int) interface{} {
	if bitutil.BitIsNotSet(b.nullBitmapBytes, i) {
		return nil
	}
	switch v := b.Data.(type) {
    {{range .Data.types -}}
	case []{{ .type }}:
		return v[i]
    {{end -}}
	default:
		panic(fmt.Errorf("unsupported type %T", v))
	}
}

func (b *bow) NewBufferFromCol(colIndex int) Buffer {
	data := b.Column(colIndex).Data()
	switch b.ColumnType(colIndex) {
    {{range .Data.types -}}
	case {{ .Type }}:
		arr := array.New{{ .Type }}Data(data)
		return Buffer{
			Data:            {{ .Type }}Values(arr),
			nullBitmapBytes: arr.NullBitmapBytes(),
		}
    {{end -}}
	default:
		panic(fmt.Errorf(
			"unsupported type %+v", b.ColumnType(colIndex)))
	}
}