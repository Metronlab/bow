package bow

import (
	"github.com/apache/arrow/go/arrow"
)

type Type int

// How to add a Type:
// - Seek corresponding arrow.GenDataType and add it in `mapArrowTTypes`
// - add a convert function with desired logic and add case in other conversion func
// - add necessary case in buffer file
// - complete GetValue bow method

const (
	//Unknown is placed first to be by default
	// when allocating Type or []Type
	Unknown = Type(iota)

	// Float64 and following types are native arrow type supported by bow
	Float64
	Int64
	Bool
	String

	//InputDependent is used in transformation like aggregation
	// when output type is infer with input type
	InputDependent
	//IteratorDependent is used in transformation like aggregation
	// when output type is infer with iteratorType
	IteratorDependent
)

var (
	mapArrowTTypes = map[arrow.DataType]Type{
		arrow.PrimitiveTypes.Float64:  Float64,
		arrow.PrimitiveTypes.Int64:    Int64,
		arrow.FixedWidthTypes.Boolean: Bool,
		arrow.BinaryTypes.String:      String,
	}
	// followings are generated by init
	mapTypeArrowDataType     map[Type]arrow.DataType
	mapArrowDataTypeNameType map[string]Type
)

func init() {
	mapTypeArrowDataType = make(map[Type]arrow.DataType)
	mapArrowDataTypeNameType = make(map[string]Type)
	for arrowDataType, bowType := range mapArrowTTypes {
		mapTypeArrowDataType[bowType] = arrowDataType
		mapArrowDataTypeNameType[arrowDataType.Name()] = bowType
	}
}

func newTypeFromArrowName(arrowName string) Type {
	t, ok := mapArrowDataTypeNameType[arrowName]
	if !ok {
		return Unknown
	}
	return t
}

func (t Type) Convert(i interface{}) interface{} {
	var val interface{}
	var ok bool
	switch t {
	case Float64:
		val, ok = ToFloat64(i)
	case Int64:
		val, ok = ToInt64(i)
	case Bool:
		val, ok = ToBool(i)
	case String:
		val, ok = ToString(i)
	}
	if ok {
		return val
	}
	return nil
}

// IsSupported ensures that the type is currently supported by Bow
// and match a convertible concrete type.
func (t Type) IsSupported() bool {
	_, ok := mapTypeArrowDataType[t]
	return ok
}

func (t Type) String() string {
	at, ok := mapTypeArrowDataType[t]
	if !ok {
		return "undefined"
	}
	return at.Name()
}

func getTypeFromArrowType(arrowType arrow.DataType) Type {
	t, ok := mapArrowTTypes[arrowType]
	if !ok {
		return Unknown
	}
	return t
}
